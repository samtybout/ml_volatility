# Setup ----
library(data.table)

# Simulation ----

sim_path = function(spp, ext, D_start = 1, t_max = 100, D_max = 10^8, i_max = 10^4){
  # Simulate a series of speciations and extinctions according to a stochastic birth-death model
  
  # Arguments
  # # Model parameters:
  # ## spp: Speciation rate
  # ## ext: Extinction rate
  # ## D_start: Initial diversity (1 by default)
  # 
  # # Simulation parameters (simulation will end if any of these limits are reached)
  # ## t_max: Maximum in-model time elapsed (100 time units by default)
  # ## D_max: Maximum standing diversity (100,000,000 by default)
  # ## i_max: Maximum number of speciation and extinction events (1,000 by default)
  
  # Output: A data frame giving standing diversity at each point when diversity changed
  ## Each row is a point in time
  ## t = Time elapsed
  ## D = Standing diversity
  
  # Initialize parameters
  t = 0
  D = D_start
  i = 0
  record = data.frame(t = t, D = D)
  
  # Simulate events until a limit is reached
  while (t < t_max && D > 0 && D < D_max && i <= i_max){
    i = i + 1
    # Determine time until next speciation or extinction event by drawing from an exponential distribution
    t_spp = rexp(1, D*spp)
    t_ext = rexp(1, D*ext)
    # Choose speciation or extinction by whichever happens sooner
    if (t_spp < t_ext){
      t = t + t_spp
      D = D + 1
    }
    else{
      t = t + t_ext
      D = D - 1
    }
    # Record data for current time
    step = data.frame(t = t, D = D)
    record = rbind(record, step)
  }
  record
}

sim_data = function(spp, ext, frame = data.frame(), t_start = 0, t_max = 100, D_max = 10^8){
  # Simulate a series of species originations and extinctions according to a stochastic birth-death mdodel
  
  # Arguments
  # # Model parameters:
  # ## spp: Speciation rate
  # ## ext: Extinction rate
  # 
  # frame: Optionally, data generated by a previous call to sim_data (by default, generates a new dataset)
  #
  # # Simulation parameters (simulation will end if any of these limits are reached)
  # ## t_max: Maximum in-model time elapsed (100 time units by default)
  # ## D_max: Maximum standing diversity (100,000,000 by default)
  
  # Output
  ## A data frame giving species origination and extinction times
  ## Each row is one species
  ## start = Origination time
  ## end = Extinction time

  # Generate one species' originatino and extinction
  t = t_start
  t_ext = rexp(1, ext)
  t_end = t_start + t_ext
  times = data.frame(start = t_start, end = t_end)
  frame = rbind(frame, times)
  t_spp = rexp(1, spp)
  t = t + t_spp
  # Generate the descendants of that species by recursive calls to sim_data
  while (t < min(t_max,t_end)){
    frame = rbind(frame, sim_data(spp, ext, t_start=t, t_max=t_max, D_max = D_max))
    t_spp = rexp(1, spp)
    t = t + t_spp
  }
  return(frame)
}

process_series = function(series){
  # Generate some supplementary statistics for a series of speciation or extinction events
  # Arguments
  ## series: A data frame of times and diversities, typically generated by sim_path
  
  # Output: The same data frame, with additional columns:
  ## dt = Time elapsed since last event
  ## dD = Change in diversity as a result of event
  ## type = Type of event; True is speciation, False is extinction
  
  len = dim(series)[1]
  dt = series$t[2:len] - series$t[1:(len-1)]
  dD = series$D[2:len] - series$D[1:(len-1)]
  type = dD == 1
  series = data.frame(t = series$t[2:len], D = series$D[1:(len-1)], dt = dt, 
                      dD = dD, type = type)
  return(series)
}

div_t = function(series,time,verbose = TRUE){
  # Given a diversity time series and a selected time, return the standing diversity at that time
  
  # Arguments
  ## series: A diversity time series, like those generated by sim_path and series_from_clade
  ## time: The time at which you wish to know the diversity
  ## verbose: If True, print a warning if the selected time is outside the time series (True by default)
  
  len = nrow(series)
  
  # Check if time is within range of series
  if (time < series$t[1]){
    if(verbose){print("Time too early")}
    return(NaN)
  }
  
  if (time > series$t[len]){
    
    # If the series ends at 0 diversity, any time beyond that is 0 diversity
    if (series$D[len] == 0){
      return(0)
    }
    
    else{
      if(verbose){print("Time out of bounds")}
      return(NaN)
    }
    
  }
  
  return(div_t_sub(series,time))
}

div_t_sub = function(series,time){
  # A helper function called by div_t
  
  # Arguments
  ## series: A diversity time series, like those generated by sim_path and series_from_clade
  ## time: The time at which you wish to know the diversity
  
  # Run a binary search algorithm to find the first recorded point after the requested time
  len = nrow(series)
  i_mid_l = len %/% 2
  t_check = series$t[i_mid_l:(i_mid_l+1)]
  
  if (t_check[1] <= time & t_check[2] >= time){
    return(series$D[i_mid_l])
  }
  
  else{
    
    if (t_check[1] > time){
      return(div_t_sub(series[1:i_mid_l,],time))
    }
    
    else {
      return(div_t_sub(series[(i_mid_l+1):len,],time))
    }
    
  }
}

discretize = function(series, binsize = 1, t_min = 0, t_max = NULL){
  # Convert a continuous-time diverstiy series into discrete time bins
  
  # Arguments
  ## series: A diversity time series, like those generated by sim_path and series_from_clade
  ## binsize: The desired bin size (1 time unit by default)
  ## t_min: The in-model time at which to begin the output series (Time 0 by default)
  ## t_max: The in-model time at which to end the output series (By default, the end of the input series)
  
  # Output: A diversity time series in discrete time, with the following columns:
  ## t = time elapsed
  ## D = standing diversity
  
  len = nrow(series)
  data = data.frame(t = c(), D = c())
  if (is.null(t_max)){
    t_max = series$t[len]
  }
  for (time in seq(t_min,t_max+binsize,binsize)){
    slice = data.frame(t = time, D = div_t(series,time,FALSE))
    data = rbind(data, slice)
  }
  return(data)
}

projection_sim = function(D_start = 1, t, spp, ext, n = 100){
  # Run a number of birth-death simulations and return the standing diversity a specified time in each series
  
  # Arguments
  ## D_start: The starting diversity (1 by default)
  ## t: The in-model time at which to record standing diversity
  ## spp: Speciation rate
  ## ext: Extinction rate
  ## n: The number of simulations (100 by default)
  
  # Output: A vector of the standing diversity in each simluation at the specified time
  
  D = c()
  for (i in 1:n){
    series = sim_path(spp, ext, D_start)
    D = c(D, div_t(series, t))
  }
  return(D)
}

# Likelihood ----

log_l_event = function(t, rate, n){
  # Calculate the negative log-likelihood of a single speciation or extinction event within a clade
  
  # Arguments
  ## t: Time elapsed since last event
  ## rate: Exponential rate of events (in this context, a speciation or extinction rate)
  ## n: Standing diversity
  
  # Output: The negative log-likelihood of the event.
  
  return(-1 * log(n * rate) + n * rate * t)
}

log_l_nonevent = function(t, rate, n){
  # Calculate the likelihood of no speciation or extinction events occurring within a clade for
  # a specified amount of time
  
  # Arguments
  ## t: Time elapsed since last event
  ## rate: Exponential rate of events (in this context, a speciation or extinction rate)
  ## n: Standing diversity
  
  # Output: The negative log-likelihood of no event
  
  l = n * rate * t
  if (l >= 0){
    return(l)
  }
  else{
    print("invalid likelihood")
    return(NaN)
  }
}

log_l_series = function(series, spp, ext, reverse = TRUE){
  # Calculate the negative log-likelihood of a series of speciation and extinction events within a clade,
  # given a characteristic speciation and extinction rate
  
  # Arguments
  ## series: A series of speciation and extinction events, like those generated by series_from_clade
  ## spp: The characteristic speciation rate of the clade
  ## ext: The characteristic extinction rate
  ## reverse: If True, take higher t values to represent earlier events (as in Millions of Years Ago)
  ##   (True by default)
  
  # Output: The negative log-likelihood of the series
  
  if (reverse){
    series$t = -1 * series$t
  }
  rates = c(spp,ext)
  len = dim(series)[1]
  change = series[2:len,] - series[1:(len-1),]
  l = 0
  for (i_event in 1:(len-1)){
    t_event = change[i_event,]$t
    D_event = series[i_event,]$D
    is_spp = change[i_event,]$D == 1
    if (is_spp){
      l = l + log_l_event(t_event, spp, D_event) + log_l_nonevent(t_event, ext, D_event)
    }
    else{
      l = l + log_l_event(t_event, ext, D_event) + log_l_nonevent(t_event, spp, D_event)
    }
  }
  return(l)
}

# Estimation ----

series_size = function(series,processed = FALSE){
  # Calculate the taxon-years (tau) of a series
  # See equation 17 in text
  
  # Arguments
  ## series: A diversity time series, like those produced by series_from_clade
  ## processed: Whether or not the seriies has the supplementary columns dt and dD (False by default)
  
  if(!processed){
    series = process_series(series)
  }
  return(sum(series$D * series$dt))
}

ml_params = function(series,processed = TRUE){
  # Calculate the maximum-likelihood speciation and extinction rate for a series, without assuming
  # the two rates are equal
  # See equations 19 and 20 in text
  
  ## Arguments
  ## series: A diversity time series, like those produced by series_from_clade
  ## processed: Whether or not the seriies has the supplementary columns dt and dD (True by default)
  
  # Output: A vector; the first entry is speciation rate, the second is extinction rate
  
  if(!processed){
    series = process_series(series)
  }
  n_spp = sum(series$type)
  n_ext = length(series[,1]) - n_spp
  size = series_size(series,processed)
  return(c(n_spp, n_ext) / size)
}

ml_vol = function(series, processed = TRUE){
  # Calculate the maximum-likelihood volatility for a series
  # See equation 24 in text
  
  ## Arguments
  ## series: A diversity time series, like those produced by series_from_clade
  ## processed: Whether or not the seriies has the supplementary columns dt and dD (True by default)
  
  # Output: The maximum-likelihood volatility
  
  if(!processed){
    series = process_series(series)
  }
  n_events = length(series$t)
  size = series_size(series, processed)
  return(n_events / size)
}

ml_vol_dist = function(pbdb_data, trials){
  # Find the maximum-likelihood volatility for fossil data across a number of random age variates.
  
  # Arguments
  #   pbdb_data: A data frame loaded from a Paleobiology Database csv, as with the load_data function
  #   trials: The number of trials/random age variates
  
  # Output: A data frame; each row is one trial. There are three variables:
  #   vol_est: The maximum-likelihood volatility estimate
  #   tau: The tau-value calculated for that trial
  #   dev: The expected standard deviation of the estimate, calculated from tau
  
  vol_estimates = data.frame(vol_est = rep(NaN, trials), tau = rep(NaN, trials))
  for(i in 1:trials){
    spp_data = compile_spp(pbdb_data)
    series = series_from_clade(spp_data)
    vol_estimates[i,] = c(ml_vol(series, TRUE), series_size(series, TRUE))
  }
  vol_estimates$dev = apply(vol_estimates["tau"], 1, size_to_dev)*vol_estimates$vol_est
  return(vol_estimates)
}

vol_freq = function(vol_dist, breaks){
  # Organize volatility estimates into bins, like a histogram.
  
  # Arguments
  #   vol_dist: A set of volatility estimates, like those generated by ml_vol_dist
  #   breaks: The bounds of the bins.
  
  # Output: a data frame of bins with two variables:
  #   mid: The mid point of the bin
  #   freq: The number of volatility estimates in that bin
  
  breakdown = hist(vol_dist$vol_est, breaks = breaks, plot = FALSE)
  freq = breakdown$counts/nrow(vol_dist)
  data = data.frame(mid = breakdown$mids, freq = freq)
  return(data)
}

vol_range_p = function(range, vol_dist){
  # Calculate the probability that a clade's volatility falls within a given range.
  
  # Arguments
  #   range: The bounds of the range (a vector of two numbers)
  #   vol_dist: A set of volatility estimates, like those generated by ml_vol_dist
  
  # Output: The probability that the clade's volatility is within the range.
  
  n = nrow(vol_dist)
  return(
    sum(
      pnorm(range[2], vol_dist$vol_est, vol_dist$dev) - 
        pnorm(range[1], vol_dist$vol_est, vol_dist$dev)
    )
    /n)
}

vol_dist_p = function(vol_dist, breaks){
  # Calculate the probability distribution that a clade's volatility falls within a series
  # of bins.
  
  # Arguments
  #   vol_dist: A set of volatility estimates, like those generated by ml_vol_dist
  #   breaks: The bounds of the bins.
  
  # Output: A probability distribution, as a data frame with three variables:
  #   lower: The lower bound of the bin.
  #   upper: The upper bound of the bin.
  #   p: The probabiltiy that the clade's volatility falls within the bin.
  
  n_bins = length(breaks) - 1
  lower = breaks[1:n_bins]
  upper = breaks[2:(n_bins+1)]
  result = data.frame(lower = lower, upper = upper, p = rep(NaN, n_bins))
  for(i_bin in 1:n_bins){
    result$p[i_bin] = vol_range_p(c(lower[i_bin], upper[i_bin]), vol_dist)
  }
  return(result)
}


# Stochastic probability functions ----

pnt = function(n0,n,t,spp,ext,alpha = NULL, beta = NULL){
  # Calculate the probability of a clade having a specified diversity after a specified amount of time,
  # given its speciation rate, extinction rate, and initial diversity
  
  # Arguments
  ## n0: The initial diversity
  ## n: The final diversity
  ## t: The amount of time passed
  ## spp: The clade's characteristic speciation rate
  ## ext: The Clade's characteristic extinction rate
  ## alpha: Deprecated
  ## beta: Deprecated
  
  # Output: The probability of diversity n after t time
  
  
  if(n0 < 0){
    print("Initial diversity cannot be negative")
    return(NaN)
  }
  
  if(spp < 0 | ext < 0){
    print("Speciation and extinction rates cannot be negative")
    return(NaN)
  }
  
  # If initial diversity is 0, diversity will always be 0
  if(n0 == 0){
    if(n == 0){
      return(1)
    }
    else{
      return(0)
    }
  }
  
  # Standing diversity can never become negative
  if(n < 0){
    return(0)
  }
  
  # If no time passes, diversity doesn't change
  if(t == 0){
    return(pnt_F(n0,n))
  }
  
  # If speciation and extinction rates are both 0, diversity doesn't change
  if(spp == 0 & ext == 0){
    return(pnt_F(n0,n))
  }
  
  # Speciation rate = 0, Extinction rate > 0
  # A "pure-death" process, mathematically analogous to radioactive decay
  if(spp == 0 & ext > 0){
    return(pnt_D(n0,n,t,ext))
  }
  
  # Speciation rate > 0, Extinction rate = 0
  # A "pure-birth" process, aka the Yule model
  if(spp > 0 & ext ==0){
    return(pnt_E(n0,n,t,spp))
  }
  
  # Speciation rate = Extinction rate > 0
  # Calculated with Equation A12 of Raup (1985)
  if(spp == ext){
    return(pnt_A(n0,n,t,spp))
  }
  
  # Speciation rate > 0, Extinction rate > 0, Speciation =/= Extinction rate
  # Calculated with Equation A13 of Raup (1985)
  return(pnt_B(n0,n,t,spp,ext))
}

# pnt calls one of these sub-functions depending on the input parameters

pnt_F = function(n0,n){
  # Speciation = Extinction = 0
  # When both rates are 0, diversity remains constant indefinitely
  if(n == n0){
    return(1)
  }
  else{
    return(0)
  }
}

pnt_D = function(n0,n,t,ext){
  # Speciation = 0
  # Extinction > 0
  # A pure death process; each extinction can be treated as an independent random
  # variable with an exponential distribution
  if (n > n0){
    return(0)
  }
  else{
    p_ext = 1 - exp(-ext * t)
    return(choose(n0,n) * (p_ext^(n0 - n)) * ((1 - p_ext)^n))
  }
}

pnt_E = function(n0,n,t,spp){
  # Speciation > 0
  # Extinction = 0
  # Yule process; equation from Stochastic Processes by Sheldon Ross, 1983
  if (n < n0){
    return(0)
  }
  else{
    return(
      choose(n - 1, n0 - 1) * exp(-1 * spp * t * n0) * (1 - exp(-spp * t))^(n - n0)
    )
  }
}

pnt_A = function(n0,n,t,vol){
  # Speciation = Extinction
  # Equations from Raup 1985
  
  # Equation A12
  if (n == 0){
    return(
      ((vol * t) / (1 + vol * t))^n0
    )
  }
  
  # Equation A16
  else{
    j = 1:min(n0,n)
    return(
      (((vol * t) / (1 + vol * t))^(n0 + n)) *
        sum(choose(n0,j) * choose(n-1,j-1) * ((vol * t)^(-2 * j)))
    )
  }
}

pnt_B = function(n0,n,t,spp,ext){
  # Speciation =/= Extinction
  # Equations from Raup 1985
  
  # Equation A13
  alpha = (ext*(exp((spp-ext)*t)-1))/(spp*exp((spp-ext)*t)-ext)
  
  # Equation A14
  if(n == 0){
    return(alpha^n0)
  }
  
  # Equation A18
  else{
    beta = alpha * spp / ext
    j = 0:min(n0,n)
    return(sum(
      choose(n0,j) * choose(n0+n-j-1,n0-1) * 
        (alpha^(n0-j)) * (beta^(n-j)) * ((1-alpha-beta)^j)
    ))
  }
}

# Projection ----

p_dist = function(n0,max,t,spp,ext){
  # Generate a probability distribution for having any diversity betwen 0 and max
  
  # Arguments
  #   n0: Initial diversity
  #   max: Maximum diversity for which to display the probability
  #   t: Time elapsed
  #   spp: Speciation rate
  #   ext: Extinction rate
  
  # Output: a data frame with two columns: D = Diversity, p = probability
  p = c()
  d = 0:max
  for (n in d){
    p = c(p,pnt(n0,n,t,spp,ext))
  }
  return(data.frame(D = d, p = p))
}

mode_n = function(n0,t,spp,ext){
  # Find the most probable, or expected diversity given initial conditions, rates, and time elapsed
  
  # Arguments
  #   n0: Initial diversity
  #   t: Time elapsed
  #   spp: Speciation rate
  #   ext: Extinction rate
  
  # Output: the most probable diversity
  expected = n0 * exp((spp - ext) * t)
  range = 0:(round(expected) * 2)
  return(mode_n_sub(n0,t,spp,ext,range))
}

mode_n_sub = function(n0,t,spp,ext,range){
  # A helper function for mode_n
  
  bot = min(range)
  top = max(range)
  # print(c(bot,top))
  if(length(range) < 3){
    p_low = pnt(n0,bot,t,spp,ext)
    p_high = pnt(n0,top,t,spp,ext)
    if(p_low > p_high){
      return(bot)
    }
    if(p_low < p_high){
      return(top)
    }
    else{
      return((bot+top)/2)
    }
  }  
  
  mid = (bot + top) %/% 2
  low = (bot + mid) %/% 2
  high = (mid + top) %/% 2
  
  p_low = pnt(n0,low,t,spp,ext)
  p_high = pnt(n0,high,t,spp,ext)
  
  if(p_low > p_high){
    return(mode_n_sub(n0,t,spp,ext,bot:mid))
  }
  else{
    return(mode_n_sub(n0,t,spp,ext,mid:top))
  }
}

conf_pnt = function(n0,t,spp,ext,int = 0.95){
  # Generate a pseudo-confidence interval for the diversity given starting conditions and time elapsed
  
  # This function first finds the most probable diversity using mode_n, then expands to the
  # next-most-probable diversity until the probability of falling within the assembled range exceeds
  # the required confidence level. Because diversity is a discrete variable, it is rarely possible
  # to construct an interval matching the confidence exactly, hence the higher confidence in the
  # output compared to the input.

  # Arguments
  #   n0: Initial diversity
  #   t: Time elapsed
  #   spp: Speciation rate
  #   ext: Extinction rate
  #   int: Confidence level (0.95 by default)
  
  # Output: A one-row data frame with three variables:
  #   lower: The lower bound of the interval
  #   upper: The upper bound of the interval
  #   p: The confidence level
  
  if(t == 0){
    return(data.frame(lower = n0, upper = n0, p = 1))
  }
  center = mode_n(n0,t,spp,ext)
  p = pnt(n0,center,t,spp,ext)
  lower = center - 1
  upper = center + 1
  while(p < int){
    p_upper = pnt(n0,upper,t,spp,ext)
    p_lower = pnt(n0,lower,t,spp,ext)
    if(p_upper > p_lower){
      p = p + p_upper
      upper = upper + 1
    }
    else{
      p = p + p_lower
      lower = lower - 1
    }
  }
  return(data.frame(lower = lower + 1, upper = upper - 1, p = p))
}

conf_series = function(n0,t_series,spp,ext,int = 0.95){
  # Generate a series of psuedo-confidence intervals for diversity at a series of times.
  
  # See conf_pnt for more information.
  
  # Arguments
  #   n0: Initial diversity
  #   t: A vector of times elapsed
  #   spp: Speciation rate
  #   ext: Extinction rate
  #   int: Confidence level (0.95 by default)
  
  # Output: A data frame with four variables:
  #   t: The time elapsed
  #   lower: The lower bound of the interval
  #   upper: The upper bound of the interval
  #   p: The confidence level
  
  data = data.frame()
  for (t in t_series){
    step = cbind(t = t, conf_pnt(n0,t,spp,ext,int))
    data = rbind(data, step)
  }
  return(data)
}

size_to_dev = function(tau){
  # Computes the standard error of volatility estimates, given the size of the dataset in
  # taxon-million-years (tau)
  
  # Arguments
  #   tau: A dataset's size in taxon-million years; can be computed with series_size
  
  # Output: The standard error of volatility estimates
  
  return(exp(-0.001984763*tau)*0.508401)
}

conf_int_from_series = function(series, dt, confidence = 0.95){
  # Given a diversity time series, generate a confidence interval for the diversity at some point
  # after the end of the series.
  
  # Arguments
  #   series: A data frame of times and diversities, typically generated by sim_path
  #   dt: The length of time after the end of the series for which to generate a confidence interval
  #   confidence: The confidence level (0.95 by default)
  
  # Output: A one-row data frame with three variables:
  #   lower: The lower bound of the interval
  #   upper: The upper bound of the interval
  #   p: The confidence level
  
  vol = ml_vol(series)
  dev = size_to_dev(series_size(series, TRUE))
  vol_high = qnorm(sqrt(confidence), vol, dev*vol)
  D_series = series$D
  n0 = D_series[length(D_series)]
  conf_int = conf_pnt(n0, dt, vol_high/2, vol_high/2, sqrt(confidence))
  conf_int$p = sqrt(confidence)*conf_int$p
  conf_int$vol = vol
  conf_int$dt = dt
  return(conf_int)
}

conf_series_from_D_series = function(D_series, dt_series, confidence = 0.95){
  # Given a diversity time series, generate a confidence interval for the diversity at some series
  # of points after the end of the series.
  
  
  # Arguments
  #   series: A data frame of times and diversities, typically generated by sim_path
  #   dt_series: A series of times elapsed since the end of the series
  #   confidence: The confidence level (0.95 by default)
  
  # Output: A data frame with four variables:
  #   t: The time elapsed
  #   lower: The lower bound of the interval
  #   upper: The upper bound of the interval
  #   p: The confidence level
  
  vol = ml_vol(D_series)
  dev = size_to_dev(series_size(D_series, TRUE))
  vol_high = qnorm(sqrt(confidence), vol, dev*vol)
  t0 = D_series$t[nrow(D_series)]
  D_series = D_series$D
  n0 = D_series[length(D_series)]
  conf_series = data.frame()
  for(dt in dt_series){
    int = conf_pnt(n0, dt, vol_high/2, vol_high/2, sqrt(confidence))
    conf_series = rbind(conf_series, int)
  }
  conf_series$p = sqrt(confidence) * conf_series$p
  conf_series$dt = dt_series
  conf_series$t = t0 - conf_series$dt
  return(conf_series)
}

t = seq(0.1,5,0.1)

# Data Management ----

load_data = function(path="./pbdb_data_full.csv", skip = 21){
  # Loads fossil data from a csv file
  
  # path: The filepath for a csv from the paleobiology database.
  pbdb_data = read.csv(path, skip = skip, stringsAsFactors = FALSE)
  return(pbdb_data)
}

select_fams = function(data, 
                       families = c("Mytilidae","Veneridae","Lucinidae","Pectinidae","Pholadomyidae")){
  # Reduce a dataset to a specified set of families
  
  # Arguments
  #   data: A data frame loaded from a Paleobiology Database csv, as with the load_data function
  #   families: A vector of family names to select.
  #     (By default: c("Mytilidae","Veneridae","Lucinidae","Pectinidae","Pholadomyidae"))
  
  # Output: The same data frame but with only the selected families
  
  return(data[data$family %in% families,])
}

remove_singletons = function(pbdb_data){
  # Remove any occurrences that are the only representative of their species in the dataset
  
  # Arguments
  #   data: A data frame loaded from a Paleobiology Database csv, as with the load_data function
  
  # Output: The same data frame but with singletons removed
  
  keep = unlist(lapply(split(duplicated(pbdb_data$accepted_no),pbdb_data$accepted_no),any))
  keep_ids = as.integer(names(keep)[keep])
  return(pbdb_data[pbdb_data$accepted_no %in% keep_ids,])
}


randomize_ages = function(pbdb_data){
  # Assign a virtual age to each fossil in a dataset, drawn randomly from a uniform distribution
  # between its minimum and maximum ages
  
  # Arguments
  #   pbdb_data: A data frame loaded from a Paleobiology Database csv, as with the load_data function
  
  # Output: The same data frame, with an additional variable, called age, which gives the randomly
  #           assigned age
  pbdb_data$age = runif(length(pbdb_data$min_ma), pbdb_data$min_ma, pbdb_data$max_ma)
  return(pbdb_data)
}

compile_spp = function(pbdb_data){
  # Generate a set of species data from paleobiology database data
  
  # Arguments
  #   pbdb_data: A data frame loaded from a Paleobiology Database csv, as with the load_data function
  
  # Output: A data frame with four variables:
  #   oldest_occ: The first fossil occurence of the species
  #   youngest_occ: The last fossil occurence of the species
  #   n_occurences: The total number of fossil occurences of the species
  #   name: The name of the species
  
  family_data = randomize_ages(pbdb_data)
  spp_list = split(family_data, family_data$accepted_name)
  spp_list = lapply(spp_list, compile_spp_sub)
  spp_data = rbindlist(spp_list)
  return(spp_data)
}

compile_spp_sub = function(species){
  # A helper function for compile_spp_sub
  name = species$accepted_name[1]
  oldest_occ = max(species$age)
  youngest_occ = min(species$age)
  n_occurences = nrow(species)
  return(data.frame(oldest_occ,youngest_occ, n_occurences, name))
}

age_cutoff = function(pbdb_data, age){
  # Remove entries dated after a specified time
  
  # Arguments
  #   pbdb_data: A data frame loaded from a Paleobiology Database csv, as with the load_data function
  #   age: The minimum desired age
  
  # Output: The same data frame, without the fossils whose minimum age is less than the cutoff
  
  return(pbdb_data[pbdb_data$min_ma < age,])
}

time_section = function(clade, min, max = 700){
  return(clade[clade$t > min & clade$t < max,])
}

series_from_clade = function(clade, range = c(Inf, 0.1)){
  # Generate a series of speciation and extinction events from species data
  
  # Arguments
  #   clade: A data frame of species ranges, like those generated by compile_spp
  #   range: A vector giving the bounds of the time series.
  #     By default, The upper bound is 0.1 Ma and there is no lower bound.
  
  # Output: A data frame of events with the following variables:
  #   t = Time of the event
  #   dD = Change in diversity as a result of the event
  #   type = TRUE for speciation, FALSE for extinction
  
  speciations = clade$oldest_occ
  speciations = speciations[speciations > range[2]]
  #speciations = speciations[-which.max(speciations)]
  n_spp = length(speciations)
  extinctions = clade$youngest_occ
  extinctions = extinctions[extinctions > range[2]]
  n_ext = length(extinctions)
  series = data.frame(t = speciations, dD = rep.int(1,n_spp), type = rep.int(TRUE,n_spp))
  series = rbind(series, data.frame(
    t = extinctions, dD = rep.int(-1,n_ext), type = rep.int(FALSE,n_ext)
  ))
  series = series[order(series$t,decreasing = TRUE),]
  n_events = length(series$t)
  D = rep.int(0,n_events)
  for (i_event in 1:(n_events)){
    change = series[i_event,]$dD
    D[(i_event):n_events] = D[(i_event):n_events] + change
  }
  series$D = D
  series$dt = c(max(clade$oldest_occ),series$t[1:(n_events-1)]) - series$t
  series = series[series$t < range[1],]
  series
}

# Miscellaneous functions ----

aic_test = function(series){
  # Perform an Akaike Information Criterion comparison for two models: one where speciation and extinction
  # rates are equal, and one where they are not.
  
  # Arguments
  #   series: A data frame of times and diversities, like those generated by sim_path
  
  # Output: A data frame with four variables:
  #   param_1: The maximum-likelihood estimate of volatility (first model) or speciation rate (second model)
  #   param_2: NaN (first model) or the maximum-likelihood estimate of extinction rate (second model)
  #   likelihood: The calculated likelihood
  #   preference: The AIC value of the model
  
  params = ml_params(series, TRUE)
  spp = params[1]
  ext = params[2]
  vol = spp + ext
  lnl1 = log_l_series(series,vol/2,vol/2)
  lnl2 = log_l_series(series,spp,ext)
  AIC_1 = 2 - 2 * lnl1
  AIC_2 = 4 - 2 * lnl2
  min_aic = min(AIC_1,AIC_2)
  
  vol_model = data.frame(param_1 = vol, param_2 = NaN, likelihood = lnl1, AIC = AIC_1,
                         preference = exp((min_aic - AIC_1)/2))
  spp_ext_model = data.frame(param_1 = spp, param_2 = ext, likelihood = lnl2, AIC = AIC_2,
                             preference = exp((min_aic - AIC_2)/2))
  
  return(rbind(vol_model,spp_ext_model))
}




normal_bins = function(mean, sd, breaks){
  # Generate a binned version of a normal distribution.
  
  # Arguments
  #   mean: The mean of the normal distribution.
  #   sd: The standard deviation of the normal distribution.
  #   breaks: The bounds of the bins.
  
  # Output: A vector of probabilities that a normally-distributed variable would fall in each
  # of the bins.
  
  n_bins = length(breaks) - 1
  return(pnorm(breaks[2:(n_bins+1)],mean,sd) - pnorm(breaks[1:n_bins],mean,sd))
}


full_run = function(pbdb_data, keep_singletons = FALSE){
  if(!keep_singletons){
    pbdb_data = remove_singletons(pbdb_data)
  }
  spp_data = compile_spp(pbdb_data)
  series = series_from_clade(spp_data)
  return(ml_vol(series))
}
